package com.cloud.thread.jmm;

/**
 * JVM：Java虚拟机
 *
 *
 * JMM：Java内存模型
 * 前言：
 * 因为有多级缓存（cpu和物理主内存的速度不一致的）
 * CPU的运行并不是直接操作内存而是先把内存里边的数据读到缓存，而内存的读和写操作的时候就会造成不一致的问题。
 *
 * JVM规范中试图定义一种 Java内存模型（Java Memory Model，简称JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，
 * 以实现让Java程序在各种平台下都能达到一致的内存访问效果。
 * 所以，推导出我们需要知道JMM
 *
 * 概念：
 * JMM（Java内存模型Java Memory Model，简称JMM）本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，
 * 通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成
 * 对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。
 *
 * 原则：
 * JMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的。
 *
 * 能干嘛？
 * 1、通过JMM来实现线程和主内存之间的抽象关系。
 * 2、屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。
 *
 *
 * 可见性：
 * 系统主内存共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现“读脏”，所以每个线程都有自己的工作内存，
 * 线程自己的工作内存中保持了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等）都必须在线程
 * 自己的工作内存中进行，而不能够直接读写主内存的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量
 * 值的传递需要通过主内存来完成。
 *
 *
 * 有序性：
 * 对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。但为了提升性能，编译器和处理器通常会对指令序列进行重新排序。
 * Java规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。
 *
 * 优缺点：
 * JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器的性能。
 * 但是，指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致（即可能产生“脏读”），简单说，
 * 两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。
 *
 * 从源码到最终执行示例图：
 * 源代码 -> 编译器优化的重排 -> 指令并行的重排 -> 内存系统的重排 -> 最终执行的指令
 *
 * 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。
 * 处理器在进行重排序时必须要考虑指令之间的数据依赖性
 * 多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。
 *
 * JMM规范下，多线程对变量的读写过程
 * 读取过程：
 * 由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个
 * 线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程
 * 对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行
 * 操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本
 * 拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图：
 *
 *
 * JMM定义了线程和主内存之间的抽象关系
 * 1、线程之间的共享变量存储在主内存中（从硬件角度来说就是内存条）
 * 2、每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读/写共享变量的副本（从硬件角度来说就是CPU的缓存，比如说寄存器、L1、L2、L3高速缓存等）
 *
 *
 * 小总结：
 * 我们定义的所有共享变量都存储在物理主内存中
 * 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中改变量的一份拷贝）
 * 线程对共享变量所有的操作都必须在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写（不能越级）
 * 不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能互相访问）
 *
 *
 * JMM规范下，多线程先行发生原则之happens-before
 * 在JMM中，如果一个操作执行的结果需要对另一个操作可见性或者 代码重排序，
 * 那么这两个操作之间必须存在happens-before（先行发生）原则。
 * 逻辑上的先后关系。
 *
 *
 happens-before总原则：
 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行
 顺序排在第二个操作之前。

 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。
 如果重排序周的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。

 happens-before之8条：
 1、次序规则
 一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作
 前面一个操作的结果可以被后续的操作获取，直白点就是前面一个操作把变量X赋值为1，那后面一个操作肯定能知道X已经变成了1

 2、锁定规则
 一个unLock操作先行发生于后面（这里的“后面”是指时间上的先后）对同一个锁的lock操作

 3、volatile变量规则
 对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的“后面”同样是指时间上的先后。

 4、传递规则
 如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C

 5、线程启动规则（Thread Start Rule）
 Thread对象的start()方法先行发生于此线程的每一个动作

 6、线程中断规则（Thread Interruption Rule）
 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
 可以通过Thread.interrupted()检测到是否发生中断
 也就是说你要先调用interrupt()方法设置过中断标志位，我才能检测到中断发送

 7、线程终止规则（Thread Termination Rule）
 线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过isAlive()等手段检测线程是否已经终止执行。

 8、对象终结规则（Finalizer Rule）
 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始
 简言之，对象没有完成初始化之前，是不能调用finalized()方法的。

 happens-before小总结
 在Java语言中，Happens-Before的语义本质上是一种可见性
 A Happens-Before B 意味着A发生过的事情对B来说是可见的，无论A事件和B事件是否发生在同一个线程里。

 JMM的设计分为两部分：
 一部分是面向程序员提供的，也就是happens-before规则，他通俗易懂的向我们阐述了一个强内存模型，我们只有理解
 happens-before规则，就可以编写并发安全的程序了。

 另一部分是针对JVM实现的，为了尽可能少的对编译器和处理器做约束从而提高性能，JMM在不影响程序执行结果的前提下对其
 不做要求，即允许优化重排序。我们只需要关注前者就行，也就是理解happens-before规则即可，其他繁杂的内容有JMM规范
 结合操作系统给我们搞定，我们只要写好代码即可。
 *
 * @author zl
 * @date 2023/4/16 18:29
 */
public class TestDemo {
    public static void main(String[] args) {
        mySort();

    }

    /**
     * 执行顺序
     * 1234
     * 2134
     * 1324
     *
     * 4123
     */
    public static void mySort() {
        int x = 11; // 语句1
        int y = 12; // 语句2
        x = x + 5; // 语句3
        y = x * x; // 语句4
        // x=16 y=256
        System.out.println("x=" + x + " y=" + y);
    }
}

class Dog {
    int age;
}