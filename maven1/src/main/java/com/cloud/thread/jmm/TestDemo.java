package com.cloud.thread.jmm;

/**
 * JVM：Java虚拟机
 *
 *
 * JMM：Java内存模型
 * 前言：
 * 因为有多级缓存（cpu和物理主内存的速度不一致的）
 * CPU的运行并不是直接操作内存而是先把内存里边的数据读到缓存，而内存的读和写操作的时候就会造成不一致的问题。
 *
 * JVM规范中试图定义一种 Java内存模型（Java Memory Model，简称JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，
 * 以实现让Java程序在各种平台下都能达到一致的内存访问效果。
 * 所以，推导出我们需要知道JMM
 *
 * 概念：
 * JMM（Java内存模型Java Memory Model，简称JMM）本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，
 * 通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成
 * 对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。
 *
 * 原则：
 * JMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的。
 *
 * 能干嘛？
 * 1、通过JMM来实现线程和主内存之间的抽象关系。
 * 2、屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。
 *
 *
 * 可见性：
 * 系统主内存共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现“读脏”，所以每个线程都有自己的工作内存，
 * 线程自己的工作内存中保持了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等）都必须在线程
 * 自己的工作内存中进行，而不能够直接读写主内存的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量
 * 值的传递需要通过主内存来完成。
 *
 *
 * 有序性：
 * 对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。但为了提升性能，编译器和处理器通常会对指令序列进行重新排序。Java规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。
 *
 * 优缺点：
 * JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器的性能。
 * 但是，指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致（即可能产生“脏读”），简单说，
 * 两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。
 *
 * 从源码到最终执行示例图：
 * 源代码 -> 编译器优化的重排 -> 指令并行的重排 -> 内存系统的重排 -> 最终执行的指令
 *
 * 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。
 * 处理器在进行重排序时必须要考虑指令之间的数据依赖性
 * 多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。
 * 
 * @author zl
 * @date 2023/4/16 18:29
 */
public class TestDemo {
    public static void main(String[] args) {
        mySort();

    }

    /**
     * 执行顺序
     * 1234
     * 2134
     * 1324
     *
     * 4123
     */
    public static void mySort() {
        int x = 11; // 语句1
        int y = 12; // 语句2
        x = x + 5; // 语句3
        y = x * x; // 语句4
        // x=16 y=256
        System.out.println("x=" + x + " y=" + y);
    }
}

class Dog {
    int age;
}